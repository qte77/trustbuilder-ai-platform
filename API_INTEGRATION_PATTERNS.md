# API Integration Patterns with TypeScript Client

This document describes the comprehensive API integration patterns implemented in this project, leveraging the TypeScript client generated by `@hey-api/openapi-ts` along with Supabase authentication.

## Overview

The project implements a type-safe, authentication-aware API integration pattern that:

- Uses generated TypeScript types from OpenAPI specification
- Handles both public and protected endpoints seamlessly
- Provides automatic authentication token injection
- Supports pagination and dynamic parameters with full type safety
- Separates concerns between authentication UI and data fetching

## Architecture Components

### 1. Generated TypeScript Client

The `@hey-api/openapi-ts` tool generates a complete TypeScript client from the backend's OpenAPI specification:

```
src/backend_client/
├── client.gen.ts      # Client configuration
├── sdk.gen.ts         # Type-safe SDK functions
├── types.gen.ts       # TypeScript interfaces for all API types
└── client/            # Client implementation
```

Key benefits:

- **Full type inference**: Every API endpoint, parameter, and response is fully typed
- **IntelliSense support**: IDE autocomplete for all API operations
- **Compile-time validation**: TypeScript prevents invalid API calls before runtime

### 2. API Client Configuration (`src/lib/api-client.ts`)

The API client is configured once at application startup:

```typescript
export function setupApiClient() {
  // Configure base URL from config
  client.setConfig({
    baseUrl: BACKEND_URL, // https://wargames-ai-backend-357559285333.us-west1.run.app
  });

  // Set up authentication interceptor
  client.interceptors.request.use(async (request) => {
    const {
      data: { session },
    } = await supabase.auth.getSession();
    if (session?.access_token) {
      request.headers.set("Authorization", `Bearer ${session.access_token}`);
    }
    return request;
  });
}
```

This ensures:

- All API calls use the configured backend URL
- Authenticated requests automatically include the Bearer token
- No manual token management in components

### 3. Universal Data Hook (`src/hooks/useApiData.ts`)

A single hook handles all API data fetching with full type safety:

```typescript
const { data, error, loading, refetch, updateParams } = useApiData(
  sdkFunction,
  {
    requiresAuth: boolean, // Declares if authentication is required
    initialParams: TParams, // Type-safe initial parameters
    enabled: boolean, // Control when fetching occurs
  },
);
```

Features:

- **Automatic type inference**: Response and parameter types are inferred from the SDK function
- **Authentication coordination**: Waits for auth state before fetching protected data
- **Dynamic parameters**: Update query/path parameters with type checking
- **Abort handling**: Cancels in-flight requests when parameters change

### 4. Component Patterns

#### ProtectedCard Pattern

The `ProtectedCard` component provides authentication-gated UI sections:

```typescript
<ProtectedCard className="user-section">
  <h2>Your Profile</h2>
  {/* This content only renders when user is authenticated */}
  <DataCard {...userInfo} title="Account Info">
    {(data) => (
      <div>
        <p>Username: {data.username}</p>  {/* TypeScript knows these fields exist! */}
        <p>Email: {data.email}</p>
      </div>
    )}
  </DataCard>
</ProtectedCard>
```

Behavior:

- Shows login prompt when not authenticated
- Displays loading state during auth check
- Renders children only when session exists
- Provides login button that triggers the login modal

#### Unprotected Data Pattern

Public data can be fetched and displayed without authentication:

```typescript
// Fetch public tournaments
const tournaments = useApiData(listTournamentsTournamentsGet)

// Display with DataCard
<DataCard {...tournaments} title="Active Tournaments">
  {(data) => (
    <ul>
      {data.map(tournament => (
        <li key={tournament.id}>
          {tournament.name} - {tournament.status}  {/* Full type safety! */}
        </li>
      ))}
    </ul>
  )}
</DataCard>
```

The same `DataCard` component handles loading, error, and empty states for both public and protected data.

### 5. Pagination with Type Safety

The `usePaginatedData` hook builds on `useApiData` to provide pagination:

```typescript
const paginatedTournaments = usePaginatedData(listTournamentsTournamentsGet, {
  pageSize: 10,
  initialParams: {
    query: {
      selection_filter: 'active'  // TypeScript validates this is a valid filter!
    }
  }
})

// Use pagination controls
<button onClick={paginatedTournaments.nextPage}>Next</button>
<span>Page {paginatedTournaments.currentPage + 1}</span>
```

The hook automatically:

- Manages `page_index` and `count` parameters
- Provides navigation methods (`nextPage`, `prevPage`, `goToPage`)
- Calculates `hasNextPage` and `hasPrevPage` states
- Maintains all other query parameters during navigation

### 6. Dynamic Parameter Updates

Parameters can be updated dynamically with full type checking:

```typescript
// TypeScript knows exactly what parameters are valid
const handleFilterChange = (newFilter: SelectionFilter) => {
  tournaments.updateParams({
    query: {
      selection_filter: newFilter, // Must be 'active' | 'upcoming' | 'completed'
      page_index: 0, // TypeScript validates these fields
      count: 20,
    },
  });
};
```

Invalid parameters are caught at compile time:

```typescript
// TypeScript Error: 'invalid' is not assignable to type SelectionFilter
tournaments.updateParams({ query: { selection_filter: "invalid" } });
```

## Complete Example: Mixed Public/Protected Dashboard

```typescript
export function Dashboard() {
  // PUBLIC DATA - No authentication required
  const healthStatus = useApiData(healthCheckHealthCheckGet)

  const paginatedTournaments = usePaginatedData(listTournamentsTournamentsGet, {
    pageSize: 10,
    initialParams: { query: { selection_filter: 'active' } }
  })

  // PROTECTED DATA - Requires authentication
  const userInfo = useApiData(getCurrentUserInfoUsersMeGet, {
    requiresAuth: true
  })

  const userBadges = usePaginatedData(listBadgesBadgesGet, {
    requiresAuth: true,
    pageSize: 5,
    initialParams: { query: { user_badges_only: true } }
  })

  return (
    <div>
      {/* Public section - always visible */}
      <DataCard {...healthStatus} title="API Status">
        {(data) => <span>Status: {data.status}</span>}
      </DataCard>

      <DataCard {...paginatedTournaments} title="Tournaments">
        {(data) => (
          <>
            {data.map(t => <TournamentItem key={t.id} tournament={t} />)}
            <Pagination {...paginatedTournaments} />
          </>
        )}
      </DataCard>

      {/* Protected section - only visible when authenticated */}
      <ProtectedCard>
        <DataCard {...userInfo} title="Your Profile">
          {(data) => <UserProfile user={data} />}
        </DataCard>

        <DataCard {...userBadges} title="Your Badges">
          {(data) => <BadgeGrid badges={data} />}
        </DataCard>
      </ProtectedCard>
    </div>
  )
}
```

## Type Safety Benefits

### 1. Compile-Time Validation

```typescript
// ✅ Valid: TypeScript knows these parameters exist
listChallengesChallengesGet({
  query: {
    tournament_id: 1,
    page_index: 0,
    count: 20,
  },
});

// ❌ Error: 'invalid_param' does not exist on type
listChallengesChallengesGet({
  query: {
    invalid_param: true, // TypeScript error!
  },
});
```

### 2. Response Type Inference

```typescript
const { data } = useApiData(getTournamentTournamentsTournamentIdGet, {
  initialParams: { path: { tournament_id: 1 } },
});

// TypeScript knows the exact shape of the response
if (data) {
  console.log(data.name); // ✅ Valid
  console.log(data.start_date); // ✅ Valid
  console.log(data.invalid); // ❌ TypeScript error!
}
```

### 3. Enum Validation

```typescript
type SelectionFilter = "active" | "upcoming" | "completed";

// TypeScript ensures only valid values are used
setFilter("active"); // ✅ Valid
setFilter("invalid"); // ❌ TypeScript error!
```

## Authentication Flow

1. **App initialization**: `setupApiClient()` configures the interceptor
2. **Protected endpoint called**: `useApiData` with `requiresAuth: true`
3. **Auth check**: Hook waits for auth state to load
4. **No session**: Data remains null, `ProtectedCard` shows login prompt
5. **User logs in**: Supabase auth state changes
6. **Automatic refetch**: Hook detects session and fetches data
7. **Token injection**: Interceptor adds Bearer token to request
8. **Data displayed**: `DataCard` renders the fetched data

## Best Practices

### 1. Use Generated SDK Functions

Always use the generated SDK functions rather than manual API calls:

```typescript
// ✅ Good: Type-safe, parameters validated
const { data } = useApiData(listTournamentsTournamentsGet);

// ❌ Bad: No type safety, manual URL construction
const { data } = useApiData(() => fetch("/tournaments"));
```

### 2. Leverage Type Inference

Let TypeScript infer types rather than manually annotating:

```typescript
// ✅ Good: Types are inferred from SDK
const { data } = useApiData(getCurrentUserInfoUsersMeGet);

// ❌ Unnecessary: Manual type annotation
const { data }: { data: UserInfo | null } = useApiData(
  getCurrentUserInfoUsersMeGet,
);
```

### 3. Handle All States

Always handle loading, error, and empty states:

```typescript
<DataCard {...apiResult} title="Data">
  {(data) => (
    // This only renders when data is successfully loaded
    <div>{data.content}</div>
  )}
</DataCard>
```

### 4. Batch Related Requests

Use multiple hooks for related data that loads independently:

```typescript
function TournamentDetails({ id }: { id: number }) {
  const tournament = useApiData(getTournamentTournamentsTournamentIdGet, {
    initialParams: { path: { tournament_id: id } },
  });

  const challenges = useApiData(listChallengesChallengesGet, {
    initialParams: { query: { tournament_id: id } },
  });

  // Both load in parallel, each with its own loading state
}
```

## Configuration

### Environment Variables

```env
VITE_SUPABASE_URL=your-supabase-url
VITE_SUPABASE_ANON_KEY=your-supabase-anon-key
```

### Backend URL (`src/config.ts`)

```typescript
export const BACKEND_URL =
  "https://wargames-ai-backend-357559285333.us-west1.run.app";
```

### CORS Requirements

The backend must allow requests from your frontend origin:

- Development: `http://localhost:5173`
- Production: Your deployed frontend URL

## Summary

This pattern provides:

- **Type safety**: Full TypeScript types from OpenAPI spec to UI
- **Authentication**: Seamless integration with Supabase auth
- **Flexibility**: Same patterns work for public and protected data
- **Developer experience**: IntelliSense, compile-time validation, and clear errors
- **Maintainability**: Single source of truth for API types
- **Performance**: Automatic request cancellation and efficient re-fetching

The combination of `@hey-api/openapi-ts` for client generation and React hooks for data fetching creates a robust, type-safe API integration that scales from simple data fetching to complex authenticated operations with pagination and dynamic parameters.
